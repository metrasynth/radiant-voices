/**
 * -- DO NOT EDIT THIS FILE DIRECTLY --
 *
 * This file was auto-generated by genrv.
 */
import { ModuleDataChunks } from "../moduleDataChunk"
import { MidiMap, ControllerMidiMap, ControllerMidiMaps } from "../controllerMidiMap"
import { Project } from "../project"
import { ModuleBase } from "./moduleBase"
import { ModuleType, OptionValues, Options } from "./moduleType"
import { SamplerBehavior } from "./samplerBehavior"
import { SamplerControllers } from "./samplerControllers"
import { SamplerControllerValues } from "./samplerControllerValues"
export namespace Sampler {
  // Intentionally duplicated enums - see also samplerEnums.ts
  // (TypeScript does not allow exporting imported enums from inside a namespace)
  export enum SampleInterpolation {
    // noinspection JSUnusedGlobalSymbols
    Off = 0,
    Linear = 1,
    Spline = 2,
  }
  export enum EnvelopeInterpolation {
    // noinspection JSUnusedGlobalSymbols
    Off = 0,
    Linear = 1,
  }
  export enum VibratoType {
    // noinspection JSUnusedGlobalSymbols
    Sin = 0,
    Saw = 1,
    Square = 2,
  }
  export enum LoopType {
    // noinspection JSUnusedGlobalSymbols
    Off = 0,
    Forward = 1,
    PingPong = 2,
  }
  export enum Format {
    // noinspection JSUnusedGlobalSymbols
    Int8 = 1,
    Int16 = 2,
    Float32 = 4,
  }
  export enum Channels {
    // noinspection JSUnusedGlobalSymbols
    Mono = 0,
    Stereo = 8,
  }
  export enum EnvelopeFlags {
    // noinspection JSUnusedGlobalSymbols
    Enabled = 1,
    Sustain = 2,
    Loop = 4,
  }
  export enum CtlNum {
    Volume = 1,
    Panning = 2,
    SampleInterpolation = 3,
    EnvelopeInterpolation = 4,
    PolyphonyCh = 5,
    RecThreshold = 6,
  }
  interface SamplerControllerMidiMaps extends ControllerMidiMaps {
    volume: ControllerMidiMap
    panning: ControllerMidiMap
    sampleInterpolation: ControllerMidiMap
    envelopeInterpolation: ControllerMidiMap
    polyphonyCh: ControllerMidiMap
    recThreshold: ControllerMidiMap
  }
  interface SamplerOptionValues extends OptionValues {
    recordOnPlay: boolean
    recordInMono: boolean
    recordWithReducedSampleRate: boolean
    recordIn_16Bit: boolean
    stopRecordingOnProjectStop: boolean
    ignoreVelocityForVolume: boolean
  }
  class SamplerOptions implements Options {
    constructor(readonly optionValues: SamplerOptionValues) {}
    // noinspection JSUnusedGlobalSymbols
    get recordOnPlay(): boolean {
      return this.optionValues.recordOnPlay
    }
    // noinspection JSUnusedGlobalSymbols
    set recordOnPlay(newValue: boolean) {
      this.optionValues.recordOnPlay = newValue
    }
    // noinspection JSUnusedGlobalSymbols
    get recordInMono(): boolean {
      return this.optionValues.recordInMono
    }
    // noinspection JSUnusedGlobalSymbols
    set recordInMono(newValue: boolean) {
      this.optionValues.recordInMono = newValue
    }
    // noinspection JSUnusedGlobalSymbols
    get recordWithReducedSampleRate(): boolean {
      return this.optionValues.recordWithReducedSampleRate
    }
    // noinspection JSUnusedGlobalSymbols
    set recordWithReducedSampleRate(newValue: boolean) {
      this.optionValues.recordWithReducedSampleRate = newValue
    }
    // noinspection JSUnusedGlobalSymbols
    get recordIn_16Bit(): boolean {
      return this.optionValues.recordIn_16Bit
    }
    // noinspection JSUnusedGlobalSymbols
    set recordIn_16Bit(newValue: boolean) {
      this.optionValues.recordIn_16Bit = newValue
    }
    // noinspection JSUnusedGlobalSymbols
    get stopRecordingOnProjectStop(): boolean {
      return this.optionValues.stopRecordingOnProjectStop
    }
    // noinspection JSUnusedGlobalSymbols
    set stopRecordingOnProjectStop(newValue: boolean) {
      this.optionValues.stopRecordingOnProjectStop = newValue
    }
    // noinspection JSUnusedGlobalSymbols
    get ignoreVelocityForVolume(): boolean {
      return this.optionValues.ignoreVelocityForVolume
    }
    // noinspection JSUnusedGlobalSymbols
    set ignoreVelocityForVolume(newValue: boolean) {
      this.optionValues.ignoreVelocityForVolume = newValue
    }
  }
  export class Module extends ModuleBase implements ModuleType {
    name = "Sampler"
    flags = 33881
    readonly typeName = "Sampler"
    readonly optionsChnm = 257
    readonly controllerSetters = [
      (val: number) => {
        this.controllerValues.volume = val
      },
      (val: number) => {
        this.controllerValues.panning = val
      },
      (val: number) => {
        this.controllerValues.sampleInterpolation = val
      },
      (val: number) => {
        this.controllerValues.envelopeInterpolation = val
      },
      (val: number) => {
        this.controllerValues.polyphonyCh = val
      },
      (val: number) => {
        this.controllerValues.recThreshold = val
      },
    ]
    readonly controllerValues: SamplerControllerValues = {
      volume: 256,
      panning: 0,
      sampleInterpolation: SampleInterpolation.Spline,
      envelopeInterpolation: EnvelopeInterpolation.Linear,
      polyphonyCh: 8,
      recThreshold: 4,
    }
    readonly controllers: SamplerControllers = new SamplerControllers(
      this,
      this.controllerValues
    )
    readonly c = this.controllers
    readonly midiMaps: SamplerControllerMidiMaps = {
      volume: new ControllerMidiMap(),
      panning: new ControllerMidiMap(),
      sampleInterpolation: new ControllerMidiMap(),
      envelopeInterpolation: new ControllerMidiMap(),
      polyphonyCh: new ControllerMidiMap(),
      recThreshold: new ControllerMidiMap(),
    }
    readonly optionValues: SamplerOptionValues = {
      recordOnPlay: false,
      recordInMono: false,
      recordWithReducedSampleRate: false,
      recordIn_16Bit: false,
      stopRecordingOnProjectStop: false,
      ignoreVelocityForVolume: false,
    }
    readonly options: SamplerOptions = new SamplerOptions(this.optionValues)
    readonly o = this.options
    behavior?: SamplerBehavior
    constructor() {
      super()
      this.behavior = new SamplerBehavior(this)
    }
    attachTo(project: Project): AttachedModule {
      return super.attachTo(project) as AttachedModule
    }
    setRawControllerValue(ctlNum: number, value: number) {
      const { controllerValues: cv } = this
      switch (ctlNum) {
        case 1:
          cv.volume = value
          break
        case 2:
          cv.panning = value
          break
        case 3:
          cv.sampleInterpolation = value
          break
        case 4:
          cv.envelopeInterpolation = value
          break
        case 5:
          cv.polyphonyCh = value
          break
        case 6:
          cv.recThreshold = value
          break
      }
    }
    *rawControllerValues(): Generator<number> {
      const { controllerValues: cv } = this
      yield cv.volume
      yield cv.panning
      yield cv.sampleInterpolation
      yield cv.envelopeInterpolation
      yield cv.polyphonyCh
      yield cv.recThreshold
    }
    setMidiMaps(midiMaps: MidiMap[]) {
      this.midiMaps.volume = midiMaps[0] || {
        channel: 0,
        messageType: 0,
        messageParameter: 0,
        slope: 0,
      }
      this.midiMaps.panning = midiMaps[1] || {
        channel: 0,
        messageType: 0,
        messageParameter: 0,
        slope: 0,
      }
      this.midiMaps.sampleInterpolation = midiMaps[2] || {
        channel: 0,
        messageType: 0,
        messageParameter: 0,
        slope: 0,
      }
      this.midiMaps.envelopeInterpolation = midiMaps[3] || {
        channel: 0,
        messageType: 0,
        messageParameter: 0,
        slope: 0,
      }
      this.midiMaps.polyphonyCh = midiMaps[4] || {
        channel: 0,
        messageType: 0,
        messageParameter: 0,
        slope: 0,
      }
      this.midiMaps.recThreshold = midiMaps[5] || {
        channel: 0,
        messageType: 0,
        messageParameter: 0,
        slope: 0,
      }
    }
    midiMapsArray(): MidiMap[] {
      const a: MidiMap[] = []
      a.push(this.midiMaps.volume)
      a.push(this.midiMaps.panning)
      a.push(this.midiMaps.sampleInterpolation)
      a.push(this.midiMaps.envelopeInterpolation)
      a.push(this.midiMaps.polyphonyCh)
      a.push(this.midiMaps.recThreshold)
      return a
    }
    rawOptionBytes(): Uint8Array {
      const bytes = new Uint8Array(6)
      const { optionValues: ov } = this
      bytes[0] = Number(ov.recordOnPlay)
      bytes[1] = Number(ov.recordInMono)
      bytes[2] = Number(ov.recordWithReducedSampleRate)
      bytes[3] = Number(ov.recordIn_16Bit)
      bytes[4] = Number(ov.stopRecordingOnProjectStop)
      bytes[5] = Number(ov.ignoreVelocityForVolume)
      return bytes
    }
    setOptions(dataChunks: ModuleDataChunks) {
      let chdt
      for (const dataChunk of dataChunks) {
        if (dataChunk.chnm == this.optionsChnm) {
          chdt = dataChunk.chdt
          break
        }
      }
      if (chdt) {
        this.optionValues.recordOnPlay = Boolean(chdt[0])
        this.optionValues.recordInMono = Boolean(chdt[1])
        this.optionValues.recordWithReducedSampleRate = Boolean(chdt[2])
        this.optionValues.recordIn_16Bit = Boolean(chdt[3])
        this.optionValues.stopRecordingOnProjectStop = Boolean(chdt[4])
        this.optionValues.ignoreVelocityForVolume = Boolean(chdt[5])
      }
    }
  }
  export class AttachedModule extends Module {
    get index(): number {
      if (this._index === undefined) {
        throw new Error("Attached module has empty index")
      }
      return this._index
    }
    set index(_: number) {
      throw new Error("Module index can only be assigned once")
    }
  }
}
