/**
 * -- DO NOT EDIT THIS FILE DIRECTLY --
 *
 * This file was auto-generated by genrv.
 */
import { ModuleDataChunks } from "../moduleDataChunk"
import { MidiMap, ControllerMidiMap, ControllerMidiMaps } from "../controllerMidiMap"
import { Project } from "../project"
import { ModuleBase } from "./moduleBase"
import {
  ControllerValues,
  Controllers,
  ModuleType,
  OptionValues,
  Options,
} from "./moduleType"
import { MetaModuleBehavior } from "./metaModuleBehavior"
export namespace MetaModule {
  export const enum PlayPatterns {
    // noinspection JSUnusedGlobalSymbols
    Off = 0,
    On = 1,
    OnNoRepeat = 2,
  }
  interface MetaModuleControllerValues extends ControllerValues {
    volume: number
    inputModule: number
    playPatterns: PlayPatterns
    bpm: number
    tpl: number
  }
  class MetaModuleControllers implements Controllers {
    constructor(readonly controllerValues: MetaModuleControllerValues) {}
    // noinspection JSUnusedGlobalSymbols
    get volume(): number {
      return this.controllerValues.volume
    }
    // noinspection JSUnusedGlobalSymbols
    set volume(newValue: number) {
      const { controllerValues } = this
      newValue = Math.min(Math.max(newValue, 0), 1024)
      controllerValues.volume = newValue
    }
    // noinspection JSUnusedGlobalSymbols
    get inputModule(): number {
      return this.controllerValues.inputModule
    }
    // noinspection JSUnusedGlobalSymbols
    set inputModule(newValue: number) {
      const { controllerValues } = this
      newValue = Math.min(Math.max(newValue, 1), 256)
      controllerValues.inputModule = newValue
    }
    // noinspection JSUnusedGlobalSymbols
    get playPatterns(): PlayPatterns {
      return this.controllerValues.playPatterns
    }
    // noinspection JSUnusedGlobalSymbols
    set playPatterns(newValue: PlayPatterns) {
      const { controllerValues } = this
      controllerValues.playPatterns = newValue
    }
    // noinspection JSUnusedGlobalSymbols
    get bpm(): number {
      return this.controllerValues.bpm
    }
    // noinspection JSUnusedGlobalSymbols
    set bpm(newValue: number) {
      const { controllerValues } = this
      newValue = Math.min(Math.max(newValue, 1), 800)
      controllerValues.bpm = newValue
    }
    // noinspection JSUnusedGlobalSymbols
    get tpl(): number {
      return this.controllerValues.tpl
    }
    // noinspection JSUnusedGlobalSymbols
    set tpl(newValue: number) {
      const { controllerValues } = this
      newValue = Math.min(Math.max(newValue, 1), 31)
      controllerValues.tpl = newValue
    }
  }
  interface MetaModuleControllerMidiMaps extends ControllerMidiMaps {
    volume: ControllerMidiMap
    inputModule: ControllerMidiMap
    playPatterns: ControllerMidiMap
    bpm: ControllerMidiMap
    tpl: ControllerMidiMap
  }
  interface MetaModuleOptionValues extends OptionValues {
    userDefinedControllers: number
    arpeggiator: boolean
    applyVelocityToProject: boolean
    eventOutput: boolean
  }
  class MetaModuleOptions implements Options {
    constructor(readonly optionValues: MetaModuleOptionValues) {}
    // noinspection JSUnusedGlobalSymbols
    get userDefinedControllers(): number {
      return this.optionValues.userDefinedControllers
    }
    // noinspection JSUnusedGlobalSymbols
    set userDefinedControllers(newValue: number) {
      if (newValue < 0 || newValue > 27) {
        throw new Error("Option value is out of range")
      }
      this.optionValues.userDefinedControllers = newValue
    }
    // noinspection JSUnusedGlobalSymbols
    get arpeggiator(): boolean {
      return this.optionValues.arpeggiator
    }
    // noinspection JSUnusedGlobalSymbols
    set arpeggiator(newValue: boolean) {
      this.optionValues.arpeggiator = newValue
    }
    // noinspection JSUnusedGlobalSymbols
    get applyVelocityToProject(): boolean {
      return this.optionValues.applyVelocityToProject
    }
    // noinspection JSUnusedGlobalSymbols
    set applyVelocityToProject(newValue: boolean) {
      this.optionValues.applyVelocityToProject = newValue
    }
    // noinspection JSUnusedGlobalSymbols
    get eventOutput(): boolean {
      return this.optionValues.eventOutput
    }
    // noinspection JSUnusedGlobalSymbols
    set eventOutput(newValue: boolean) {
      this.optionValues.eventOutput = newValue
    }
  }
  export class Module extends ModuleBase implements ModuleType {
    name = "MetaModule"
    flags = 32849
    readonly typeName = "MetaModule"
    readonly optionsChnm = 2
    readonly controllerSetters = [
      (val: number) => {
        this.controllerValues.volume = val
      },
      (val: number) => {
        this.controllerValues.inputModule = val
      },
      (val: number) => {
        this.controllerValues.playPatterns = val
      },
      (val: number) => {
        this.controllerValues.bpm = val
      },
      (val: number) => {
        this.controllerValues.tpl = val
      },
    ]
    readonly controllerValues: MetaModuleControllerValues = {
      volume: 256,
      inputModule: 1,
      playPatterns: PlayPatterns.Off,
      bpm: 125,
      tpl: 6,
    }
    readonly controllers: MetaModuleControllers = new MetaModuleControllers(
      this.controllerValues
    )
    readonly c = this.controllers
    readonly midiMaps: MetaModuleControllerMidiMaps = {
      volume: new ControllerMidiMap(),
      inputModule: new ControllerMidiMap(),
      playPatterns: new ControllerMidiMap(),
      bpm: new ControllerMidiMap(),
      tpl: new ControllerMidiMap(),
    }
    readonly optionValues: MetaModuleOptionValues = {
      userDefinedControllers: 0,
      arpeggiator: false,
      applyVelocityToProject: false,
      eventOutput: true,
    }
    readonly options: MetaModuleOptions = new MetaModuleOptions(this.optionValues)
    readonly o = this.options
    behavior?: MetaModuleBehavior
    constructor() {
      super()
      this.behavior = new MetaModuleBehavior(this)
    }
    attachTo(project: Project): Module {
      return super.attachTo(project) as Module
    }
    *rawControllerValues(): Generator<number> {
      const { controllerValues: cv } = this
      yield cv.volume
      yield cv.inputModule
      yield cv.playPatterns
      yield cv.bpm
      yield cv.tpl
    }
    setMidiMaps(midiMaps: MidiMap[]) {
      this.midiMaps.volume = midiMaps[0]
      this.midiMaps.inputModule = midiMaps[1]
      this.midiMaps.playPatterns = midiMaps[2]
      this.midiMaps.bpm = midiMaps[3]
      this.midiMaps.tpl = midiMaps[4]
    }
    midiMapsArray(): MidiMap[] {
      const a: MidiMap[] = []
      a.push(this.midiMaps.volume)
      a.push(this.midiMaps.inputModule)
      a.push(this.midiMaps.playPatterns)
      a.push(this.midiMaps.bpm)
      a.push(this.midiMaps.tpl)
      return a
    }
    rawOptionBytes(): Uint8Array {
      const bytes = new Uint8Array(4)
      const { optionValues: ov } = this
      bytes[0] = ov.userDefinedControllers
      bytes[1] = Number(ov.arpeggiator)
      bytes[2] = Number(ov.applyVelocityToProject)
      bytes[3] = Number(!ov.eventOutput)
      return bytes
    }
    setOptions(dataChunks: ModuleDataChunks) {
      let chdt
      for (const dataChunk of dataChunks) {
        if (dataChunk.chnm == this.optionsChnm) {
          chdt = dataChunk.chdt
          break
        }
      }
      if (chdt) {
        this.optionValues.userDefinedControllers = chdt[0]
        this.optionValues.arpeggiator = Boolean(chdt[1])
        this.optionValues.applyVelocityToProject = Boolean(chdt[2])
        this.optionValues.eventOutput = !Boolean(chdt[3])
      }
    }
  }
}
