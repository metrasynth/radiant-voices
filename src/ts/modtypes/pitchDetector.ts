/**
 * -- DO NOT EDIT THIS FILE DIRECTLY --
 *
 * This file was auto-generated by genrv.
 */
import { MidiMap, ControllerMidiMap, ControllerMidiMaps } from "../controllerMidiMap"
import { Project } from "../project"
import { ModuleBase } from "./moduleBase"
import { ModuleType, OptionValues, Options } from "./moduleType"
import { PitchDetectorBehavior } from "./pitchDetectorBehavior"
import { PitchDetectorControllers } from "./pitchDetectorControllers"
import { PitchDetectorControllerValues } from "./pitchDetectorControllerValues"
export namespace PitchDetector {
  // Intentionally duplicated enums - see also pitchDetectorEnums.ts
  // (TypeScript does not allow exporting imported enums from inside a namespace)
  export enum Algorithm {
    // noinspection JSUnusedGlobalSymbols
    ZeroCrossing = 0,
    Autocorrelation = 1,
    Cepstrum = 2,
  }
  export enum RollOff {
    // noinspection JSUnusedGlobalSymbols
    Db_12 = 0,
    Db_24 = 1,
    Db_36 = 2,
    Db_48 = 3,
  }
  export enum SampleRate {
    // noinspection JSUnusedGlobalSymbols
    Hz_12 = 0,
    Hz_24 = 1,
    Hz_44 = 2,
  }
  export enum Buffer {
    // noinspection JSUnusedGlobalSymbols
    Ms_5m = 0,
    Ms_10 = 1,
    Ms_21 = 2,
    Ms_42 = 3,
    Ms_85 = 4,
  }
  export enum CtlNum {
    Algorithm = 1,
    Threshold = 2,
    Gain = 3,
    Microtones = 4,
    DetectorFinetune = 5,
    LpFilterFreqHz = 6,
    LpFilterRolloff = 7,
    Alg_1_2SampleRate = 8,
    Alg_1_2Buffer = 9,
    Alg_1_2BufferOverlapPct = 10,
    Alg_1Sensitivity = 11,
    RecordNotes = 12,
  }
  interface PitchDetectorControllerMidiMaps extends ControllerMidiMaps {
    algorithm: ControllerMidiMap
    threshold: ControllerMidiMap
    gain: ControllerMidiMap
    microtones: ControllerMidiMap
    detectorFinetune: ControllerMidiMap
    lpFilterFreqHz: ControllerMidiMap
    lpFilterRolloff: ControllerMidiMap
    alg_1_2SampleRate: ControllerMidiMap
    alg_1_2Buffer: ControllerMidiMap
    alg_1_2BufferOverlapPct: ControllerMidiMap
    alg_1Sensitivity: ControllerMidiMap
    recordNotes: ControllerMidiMap
  }
  interface PitchDetectorOptionValues extends OptionValues {}
  class PitchDetectorOptions implements Options {
    constructor(readonly optionValues: PitchDetectorOptionValues) {}
  }
  export class Module extends ModuleBase implements ModuleType {
    name = "Pitch Detector"
    flags = 8785985
    readonly typeName = "Pitch Detector"
    readonly controllerSetters = [
      (val: number) => {
        this.controllerValues.algorithm = val
      },
      (val: number) => {
        this.controllerValues.threshold = val
      },
      (val: number) => {
        this.controllerValues.gain = val
      },
      (val: number) => {
        this.controllerValues.microtones = Boolean(val)
      },
      (val: number) => {
        this.controllerValues.detectorFinetune = val
      },
      (val: number) => {
        this.controllerValues.lpFilterFreqHz = val
      },
      (val: number) => {
        this.controllerValues.lpFilterRolloff = val
      },
      (val: number) => {
        this.controllerValues.alg_1_2SampleRate = val
      },
      (val: number) => {
        this.controllerValues.alg_1_2Buffer = val
      },
      (val: number) => {
        this.controllerValues.alg_1_2BufferOverlapPct = val
      },
      (val: number) => {
        this.controllerValues.alg_1Sensitivity = val
      },
      (val: number) => {
        this.controllerValues.recordNotes = Boolean(val)
      },
    ]
    readonly controllerValues: PitchDetectorControllerValues = {
      algorithm: Algorithm.Autocorrelation,
      threshold: 80,
      gain: 0,
      microtones: true,
      detectorFinetune: 0,
      lpFilterFreqHz: 1000,
      lpFilterRolloff: RollOff.Db_12,
      alg_1_2SampleRate: SampleRate.Hz_12,
      alg_1_2Buffer: Buffer.Ms_21,
      alg_1_2BufferOverlapPct: 50,
      alg_1Sensitivity: 10,
      recordNotes: false,
    }
    readonly controllers: PitchDetectorControllers = new PitchDetectorControllers(
      this,
      this.controllerValues
    )
    readonly c = this.controllers
    readonly midiMaps: PitchDetectorControllerMidiMaps = {
      algorithm: new ControllerMidiMap(),
      threshold: new ControllerMidiMap(),
      gain: new ControllerMidiMap(),
      microtones: new ControllerMidiMap(),
      detectorFinetune: new ControllerMidiMap(),
      lpFilterFreqHz: new ControllerMidiMap(),
      lpFilterRolloff: new ControllerMidiMap(),
      alg_1_2SampleRate: new ControllerMidiMap(),
      alg_1_2Buffer: new ControllerMidiMap(),
      alg_1_2BufferOverlapPct: new ControllerMidiMap(),
      alg_1Sensitivity: new ControllerMidiMap(),
      recordNotes: new ControllerMidiMap(),
    }
    readonly optionValues: PitchDetectorOptionValues = {}
    readonly options: PitchDetectorOptions = new PitchDetectorOptions(this.optionValues)
    readonly o = this.options
    behavior?: PitchDetectorBehavior
    constructor() {
      super()
      this.behavior = new PitchDetectorBehavior(this)
    }
    attachTo(project: Project): AttachedModule {
      return super.attachTo(project) as AttachedModule
    }
    setRawControllerValue(ctlNum: number, value: number) {
      const { controllerValues: cv } = this
      switch (ctlNum) {
        case 1:
          cv.algorithm = value
          break
        case 2:
          cv.threshold = value
          break
        case 3:
          cv.gain = value
          break
        case 4:
          cv.microtones = Boolean(value)
          break
        case 5:
          cv.detectorFinetune = value
          break
        case 6:
          cv.lpFilterFreqHz = value
          break
        case 7:
          cv.lpFilterRolloff = value
          break
        case 8:
          cv.alg_1_2SampleRate = value
          break
        case 9:
          cv.alg_1_2Buffer = value
          break
        case 10:
          cv.alg_1_2BufferOverlapPct = value
          break
        case 11:
          cv.alg_1Sensitivity = value
          break
        case 12:
          cv.recordNotes = Boolean(value)
          break
      }
    }
    *rawControllerValues(): Generator<number> {
      const { controllerValues: cv } = this
      yield cv.algorithm
      yield cv.threshold
      yield cv.gain
      yield Number(cv.microtones)
      yield cv.detectorFinetune
      yield cv.lpFilterFreqHz
      yield cv.lpFilterRolloff
      yield cv.alg_1_2SampleRate
      yield cv.alg_1_2Buffer
      yield cv.alg_1_2BufferOverlapPct
      yield cv.alg_1Sensitivity
      yield Number(cv.recordNotes)
    }
    setMidiMaps(midiMaps: MidiMap[]) {
      this.midiMaps.algorithm = midiMaps[0] || {
        channel: 0,
        messageType: 0,
        messageParameter: 0,
        slope: 0,
      }
      this.midiMaps.threshold = midiMaps[1] || {
        channel: 0,
        messageType: 0,
        messageParameter: 0,
        slope: 0,
      }
      this.midiMaps.gain = midiMaps[2] || {
        channel: 0,
        messageType: 0,
        messageParameter: 0,
        slope: 0,
      }
      this.midiMaps.microtones = midiMaps[3] || {
        channel: 0,
        messageType: 0,
        messageParameter: 0,
        slope: 0,
      }
      this.midiMaps.detectorFinetune = midiMaps[4] || {
        channel: 0,
        messageType: 0,
        messageParameter: 0,
        slope: 0,
      }
      this.midiMaps.lpFilterFreqHz = midiMaps[5] || {
        channel: 0,
        messageType: 0,
        messageParameter: 0,
        slope: 0,
      }
      this.midiMaps.lpFilterRolloff = midiMaps[6] || {
        channel: 0,
        messageType: 0,
        messageParameter: 0,
        slope: 0,
      }
      this.midiMaps.alg_1_2SampleRate = midiMaps[7] || {
        channel: 0,
        messageType: 0,
        messageParameter: 0,
        slope: 0,
      }
      this.midiMaps.alg_1_2Buffer = midiMaps[8] || {
        channel: 0,
        messageType: 0,
        messageParameter: 0,
        slope: 0,
      }
      this.midiMaps.alg_1_2BufferOverlapPct = midiMaps[9] || {
        channel: 0,
        messageType: 0,
        messageParameter: 0,
        slope: 0,
      }
      this.midiMaps.alg_1Sensitivity = midiMaps[10] || {
        channel: 0,
        messageType: 0,
        messageParameter: 0,
        slope: 0,
      }
      this.midiMaps.recordNotes = midiMaps[11] || {
        channel: 0,
        messageType: 0,
        messageParameter: 0,
        slope: 0,
      }
    }
    midiMapsArray(): MidiMap[] {
      const a: MidiMap[] = []
      a.push(this.midiMaps.algorithm)
      a.push(this.midiMaps.threshold)
      a.push(this.midiMaps.gain)
      a.push(this.midiMaps.microtones)
      a.push(this.midiMaps.detectorFinetune)
      a.push(this.midiMaps.lpFilterFreqHz)
      a.push(this.midiMaps.lpFilterRolloff)
      a.push(this.midiMaps.alg_1_2SampleRate)
      a.push(this.midiMaps.alg_1_2Buffer)
      a.push(this.midiMaps.alg_1_2BufferOverlapPct)
      a.push(this.midiMaps.alg_1Sensitivity)
      a.push(this.midiMaps.recordNotes)
      return a
    }
  }
  export class AttachedModule extends Module {
    get index(): number {
      if (this._index === undefined) {
        throw new Error("Attached module has empty index")
      }
      return this._index
    }
    set index(_: number) {
      throw new Error("Module index can only be assigned once")
    }
  }
}
