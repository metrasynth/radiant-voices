{# isort:skip_file -#}
# -- DO NOT EDIT THIS FILE DIRECTLY --
"""
Base class for {{ modtype_name }}

This file was auto-generated by genrv.
"""
{%- if modtype.enums %}
from enum import IntEnum
{% endif %}
{%- if modtype.options %}
from rv.option import Option
{% endif %}
{%- if modtype.controllers %}
from rv.controller import Controller
    {% for ctl in modtype.controllers -%}
        {% for cname, cdef in ctl.items() %}
            {% if "min" in cdef and "max" in cdef %}
{% if cdef.compact %}from rv.controller import CompactRange{% endif %}
{% if cdef.no_offset %}from rv.controller import NoOffsetRange{% endif %}
            {% endif %}
{% if cdef.depends_on %}from rv.controller import DependentRange, WarnOnlyRange{% endif %}
        {%- endfor %}
    {%- endfor %}
{% endif %}
{%- for chunk in modtype.chunks %}
    {%- if chunk.parent_type == "Array" %}
from rv.chunks import ArrayChunk
    {% endif %}
{% endfor %}

class Base{{ modtype_name }}:
    name = {{ modtype_name | repr }}
    mtype = {{ (modtype.type or modtype_name) | repr }}
    mgroup = {{ modtype.group | repr }}
    flags = {{ (modtype.defaultFlags or 0) | hex }}

{% for ename, e in (modtype.enums or {}).items() %}
    class {{ ename }}(IntEnum):
    {%- for ekey, eval in e.items() %}
        {{ ekey | enumname }} = {{ eval }}
    {%- endfor %}
{% endfor %}

{% for ctl in modtype.controllers -%}
    {% for cname, cdef in ctl.items() %}
        {% if cname == "in" %}
            {% set cname = "in_" %}
        {% endif %}
    {{ cname }} = Controller(
        {% if "min" in cdef and "max" in cdef %}
            {% if cdef.compact %}CompactRange{% endif %}
            {% if cdef.no_offset %}NoOffsetRange{% endif %}
            ({{ cdef.min }}, {{ cdef.max }}),
            {{ cdef.default }}
        {% elif "enum" in cdef and "default" in cdef %}
            {{ cdef.enum }}, {{ cdef.enum }}.{{ cdef.default | enumname }}
        {% elif "bool" in cdef %}
            bool, {{ cdef.default | repr }}
        {% elif "depends_on" in cdef %}
            DependentRange(
                {{ cdef.depends_on | repr }},
            {
                {% set enumclass = ctlmap[cdef.depends_on].enum %}
                {% for enumval, rangeinfo in cdef.ranges.items() %}
                    {{ enumclass }}.{{ enumval | enumname }}: WarnOnlyRange(
                        {{ rangeinfo.min }}, {{ rangeinfo.max }}
                    ),
                {% endfor %}
            },
            {% for firstrangeinfo in cdef.ranges.values() %}
                {% if loop.first %}
                    WarnOnlyRange(
                        {{ firstrangeinfo.min }}, {{ firstrangeinfo.max }}
                    )
                {% endif %}
            {% endfor %}
            )
            , {{ cdef.default }}
        {% endif %}
        {% if "attached" in cdef and not cdef.attached %}
            , attached=False
        {% endif %}
    )
    {%- endfor %}
{%- endfor %}

{% for opt in modtype.options -%}
    {% for oname, ospec in opt.items() %}
    {{ oname }} = Option(
        name={{ oname | repr }},
        {% if ospec.number %}
            number={{ ospec.number }},
        {% endif %}
        byte={{ ospec.byte }},
        bit={{ ospec.bit }},
        size={{ ospec.size }},
        {% if ospec.min %}
            min={{ ospec.min }},
            max={{ ospec.max }},
        {% elif ospec.inverted %}
            inverted={{ ospec.inverted | repr }},
        {% endif %}
        {% if ospec.exclusive_of %}
            exclusive_of={{ ospec.exclusive_of | repr }},
        {% endif %}
        default={{ ospec.default | repr }},
    )
    {%- endfor %}
{%- endfor %}

{% for chunk in modtype.chunks %}
    {% if chunk.parent_type == "Array" %}
    class {{ chunk.name }}_chunk(ArrayChunk):
        chnm = {{ chunk.chnm }}
        length = {% if chunk.length %}{{ chunk.length }}{% else %}{{ chunk.default | length }}{% endif %}
        type = {% if chunk.element_type == "unsigned short" %}"H"{% elif chunk.element_type == "unsigned byte" %}"B"{% else %}None{% endif %}
        element_size = {% if chunk.element_type == "unsigned short" %}2{% elif chunk.element_type == "unsigned byte" %}1{% else %}None{% endif %}
        {% if "min" in chunk %}
        min_value = {{ chunk.min }}
        {% endif %}
        {% if "max" in chunk %}
        max_value = {{ chunk.max }}
        {% endif %}
        {% if "enum" not in chunk %}
        default = {{ chunk.default | repr }}
        {% endif %}
        {% if "enum" in chunk %}
        @property
        def default(self):
            return [
                {% for d in chunk.default %}
                    Base{{ modtype_name }}.{{ chunk.enum }}.{{ d }},
                {% endfor %}
            ]

        @property
        def encoded_values(self):
            return [x.value for x in self.values]

        @property
        def python_type(self):
            return Base{{ modtype_name }}.{{ chunk.enum }}
        {% endif %}
    {% endif %}
{% endfor %}
